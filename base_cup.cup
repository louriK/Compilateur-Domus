// Specification JCup
import java_cup.runtime.*;
import java.util.*;
import java.io.*;

action code {:

	// listes principales
	List<Object[]> appareils = new ArrayList<Object[]>();
	List<Object[]> interfaces= new ArrayList<Object[]>();
	List<Object[]> scenarios = new ArrayList<Object[]>();
	List<Object[]> associations = new ArrayList<Object[]>();
	ArrayList<Object[]> programmations = new ArrayList<Object[]>();
	List<Object[]> enums_appareils= new ArrayList<Object[]>();
	List<Object[]> enums_dates= new ArrayList<Object[]>();

	// listes de test ou temporaires
	List<Object> temp = new ArrayList<Object>();
	ArrayList<Object> liste_association_scenarios = new ArrayList<Object>();
	ArrayList<Object> liste_programme_date = new ArrayList<Object>();
		
	// variable de tests
	String sortie_erreur = "";
	boolean code_valide = true;
	String type_enum;
   	String nom_scenario;

	
	class Dico {
		String [][] fonctions = new String [6][];
		String [][] etats = new String [6][];
		String [] autres_appareils;

		{
			 // 0 = eclairage, 1 = alarme, 2 = chauffage, 3 = fenetre, 4 = volet, 5 = autre_appareil
			 fonctions[0] = new String[] {"eclairage", "allumer", "eteindre", "tamiser"};
			 fonctions[1] = new String[] {"alarme", "allumer", "allumer_partiel", "eteindre"};
			 fonctions[2] = new String[] {"chauffage", "allumer", "allumer_eco", "eteindre"};
			 fonctions[3] = new String[] {"fenetre", "ouvrir", "ouvrir_partiel", "fermer", "fermer_partiel"};
			 fonctions[4] = new String[] {"volet", "ouvrir", "ouvrir_partiel", "fermer", "fermer_partiel"};
			 fonctions[5] = new String[] {"autre_appareil", "allumer", "eteindre"};

			 
			 // 0 = eclairage, 1 = alarme, 2 = chauffage, 3 = fenetre, 4 = volet, 5 = autre_appareil
			 etats[0] = new String[] {"allume", "eteint", "demi"};
			 etats[1] = new String[] {"allume", "eteint", "demi"};
			 etats[2] = new String[] {"allume", "eteint", "eco"};
			 etats[3] = new String[] {"ouvert", "ferme", "demi"};
			 etats[4] = new String[] {"ouvert", "ferme", "demi"};
			 etats[5] = new String[] {"allume", "eteint"};

			autres_appareils = new String[] {"tv", "hifi", "cafetiere", "video_proj", "lave_vaiselle", "lave_linge", "seche_linge", "ordinateur", "portail"};
		}

		public boolean getFonctions(Object appareil, String fonc) {
			if(!appareil.toString().startsWith("autre_appareil(")) {
				for(int i = 0; i < fonctions.length - 1; i++) {
					if(fonctions[i][0].equals(appareil.toString())) {
					   	for(int j = 1; j < fonctions[i].length; j++) {
							if(fonctions[i][j].equals(fonc)) return true;
						}
						return false;
					}
				}
			} else {
				// check dans autres_appareils
				appareil = appareil.toString().substring(15, appareil.toString().length() - 1);
				for(int i = 0; i < autres_appareils.length; i++) {
					if(appareil.equals(autres_appareils[i])) {
						for(int j = 1; j < fonctions[5].length; j++) {
							if(fonctions[5][j].equals(fonc)) return true;
						}
						return false;
					}
				}
			}
			return false;
		}

		boolean typeAppareilExiste(Object chaine){
         for(int i  = 0; i < fonctions.length; i++) {
				if(fonctions[i][0].equals(chaine)) {
					return true;
				}
			}
			return false;
		}
	}

	Dico d = new Dico();

	void exemple_de_fonction(String i1, String i2)
	{
		String m = "Erreur syntaxique <"+i2+"> au lieu de <"+i1+">";
		if (!(i1.equals(i2))) parser.report_error(m,null);	 
	}

	// vide la liste temp
	void vider_tampon() {
		temp.clear();
	}

	// vérifie si un appareil est présent dans la liste appareils
	boolean appareilExiste(Object chaine){
		int i  = 0;
		boolean trouve = false;
		// on recherche l'appareil
		while(i < appareils.size() && !trouve) {
			if(appareils.get(i)[0].equals(chaine.toString())) { trouve = true;}
			else i++;
		}
		return trouve;
	}

	// supprime un appareil dans la liste appareils
	void supprimer_appareil(String nom) {
		// parcours de la liste appareils
		for(int i = appareils.size() - 1; i > 0; i--) {
			// si il s'agit de l'appareil recherché, on le supprime
			if(appareils.get(i)[0].toString().equals(nom)) {appareils.remove(i); return;}
		}
	}

	// vérifie si un appareil est présent dans la liste enumAppareil
	boolean enumAppareilExiste(Object chaine){
		int i  = 0;
		boolean trouve = false;
		// on recherche l'enum
		while(i < enums_appareils.size() && !trouve) {
			if(enums_appareils.get(i)[0].toString().equals(chaine.toString())) { trouve = true;}
			else i++;
		}
		return trouve;
	}

	// recuperation du type d'un appareil
   	Object getTypeAppareil(String nom) {
		// parcours de la liste appareils
		for(int i = 0; i < appareils.size(); i++) {
			// si il s'agit de l'appareil recherché, on retourne son type
			if(appareils.get(i)[0].equals(nom)) return appareils.get(i)[2];
		}
		return "null";
	}

	// recuperation du type d'un enum	
	Object getTypeEnum(String nom) {
		// parcours de la  enums_appareils
		for(int i = 0; i < enums_appareils.size(); i++) {
			// si il s'agit de l'enum recherché, on retourne son type
			if(enums_appareils.get(i)[0].equals(nom)) return enums_appareils.get(i)[1];
		}
		return "null";
	}

	// vérifie si une interface est présente dans la liste interfacess
	boolean interfaceExiste(Object chaine){
		int i  = 0;
		boolean trouve = false;
		// on recherche l'interface
		while(i < interfaces.size() && !trouve) {
			if(interfaces.get(i)[0].toString().equals(chaine.toString())) { trouve = true;}
			else i++;
		}
		return trouve;
	}

	// vérifie si un scénario est présent dans la liste scenarios
	boolean scenarioExiste(Object chaine){
		int i = 0;
		// on recherche le scenario
		while(i < scenarios.size()) {
			if(scenarios.get(i)[0].equals(chaine.toString())) { return true;}
			else i++; 
		}
		return false;
	}
	
	// vérifie si un scénario est présent dans la liste programmations (à été programmé)
   	boolean programmeExiste(Object s){
		int i  = 0;
		boolean trouve = false;
		// recherche du scénario
		while(i < programmations.size() && !trouve) {
			if(programmations.get(i)[0].equals(s.toString())){ trouve = true;}
			else i++;
		}
		return trouve;
   	}

	// retourne l'interface recherché
   	Object[] getInterface(Object chaine){
		int i = 0;
		boolean trouve = false;
		while(i < interfaces.size() && !trouve){
			if(interfaces.get(i)[0].equals(chaine.toString())){ trouve = true;}
			else i++;
		}
		return interfaces.get(i);
	}

	// retourne le scénario recherché
	Object[] getScenario(Object chaine){
		int i = 0;
		boolean trouve = false;
		while(i < scenarios.size() && !trouve){
			if(scenarios.get(i)[0].equals(chaine.toString())){ trouve = true;}
			else i++;
		}
		return scenarios.get(i);
	}

	// retourne le programme recherché
	Object[] getProgramme(Object chaine){
		int i = 0;
		boolean trouve = false;
		while(i < programmations.size() && !trouve){
			if(programmations.get(i)[0].equals(chaine.toString())){ trouve = true;
			}else{
				i++;
			}
		}
		return programmations.get(i);
   }

   // --------------- partie association ---------------

	// ajoute un scenario à une interface
	void ajoutScenarInterface(Object inter, Object scenar){
		int i = 0;
		boolean trouve = false;
		// parcours de la liste interface
		while(i < interfaces.size() && !trouve){
			// s'il s'agit de l'interface
			if(interfaces.get(i)[0].equals(inter.toString())){
				// ajout du scenario à l'interface			
				((List<Object>) interfaces.get(i)[3]).add(scenar.toString());
				// on precise que l'interface à un scénario attribué
				if(!(Boolean)interfaces.get(i)[1])interfaces.get(i)[1] = true;
				//getScenario(scenar)[1] = true;
				trouve = true;
			}
			i++;	
		}
	}

	// ajoute une interface et son scenario à la liste d'associations
	void Association_simple(Object i, Object s){
		// si l'interface existe
		if(interfaceExiste(i)){
			// si l'interface n'a pas de scenario attribué
			if(!(Boolean)getInterface(i)[1]){
				// si le scenario existe
				if(scenarioExiste(s)){
					// ajoute du scenario à l'interface
					ajoutScenarInterface(i,s);
					// ajout de l'interface à la liste d'associations
					associations.add(new Object[] {(String)i, new ArrayList<Object>()});
					// attribution du scenario à l'interface qui vient d'être ajoutée
					((List<Object>) associations.get(associations.size()-1)[1]).add(s.toString());
				}else{
					sortie_erreur += "Erreur ligne " + parser.pline() + ": scenario "+s+" inexistant.\n";
				}
			}else{
				sortie_erreur += "Erreur ligne " + parser.pline() + ": l'interface "+i+" à déjà un ou des scénario(s) associé(s).\n";
			}
		}else{
			sortie_erreur += "Erreur ligne " + parser.pline() + ": interface "+i+" inexistante.\n";	
		}
	}

	// ajoute une interface et ses scenarii à la liste d'associations
	void Association_multiple(Object i){
		// si l'interface existe
		if(interfaceExiste(i)){
			// si l'interface n'a pas de scenario attribué
			if(!(Boolean)getInterface(i)[1]){
				// si l'interface n'est pas un interrupteur (unique interface ne pouvant accueillir plusieurs sénarios)
				if(!(((String)getInterface(i)[2]).equals("interrupteur"))){
					// si la liste de scenarii de l'interface n'est pas vide
					if(liste_association_scenarios != null){
						int j;
						// parcours de la liste de scenarii de l'interface
						for(j=0; j<liste_association_scenarios.size();j++){
							// si le scénario existe	
							if(scenarioExiste(liste_association_scenarios.get(j))){
								// ajoute du scenario à l'interface
								ajoutScenarInterface(i,liste_association_scenarios.get(j));
								// ajout de l'interface à la liste d'associations (une seule fois)
								if(j==0) associations.add(new Object[] {(String)i, new ArrayList<Object>()});
								// attribution du scenario à l'interface qui vient d'être ajoutée
								((List<Object>) associations.get(associations.size()-1)[1]).add(liste_association_scenarios.get(j));
							}else{
								sortie_erreur += "\nerreur :: scenario "+liste_association_scenarios.get(j)+" inexistant.\n";
							}
						}
					}else{
						sortie_erreur += "Erreur ligne " + parser.pline() + ": liste pour l'association à l'interface "+i+" vide.\n";			
					}
				}else{
					sortie_erreur += "Erreur ligne " + parser.pline() + ":le type de l'interface "+i+" ne permet pas l'association de scenarii.\n";
				}
			}else{
				sortie_erreur += "Erreur ligne " + parser.pline() + ": l'interface "+i+" à déjà un ou des scénario(s) associé(s).\n";
			}
		}else{
			sortie_erreur += "Erreur ligne " + parser.pline() + ": interface "+i+" inexistante.\n";	
		}
		// on vide la liste des scenarii pour les suivants
		liste_association_scenarios.clear();
	}
	
	// affichage du tableau associations
	String associationToString(){
		String retour = "\n---- association ----\n";
		for(int i=0;i<associations.size();i++){
			retour += ((String)associations.get(i)[0]) + " " + (associations.get(i)[1]) + "\n";
		}
		return retour;
   }

   // ---------------programme---------------

	// ajoute une date à un programme
	void ajouterDateProgramme(Object s, int[] date){
		int i = 0;
		boolean trouve = false;
		// parcours de la liste programmations pour trouver le bon programme
		while(i < programmations.size() && !trouve){
			if(programmations.get(i)[0].equals(s.toString())){	
				// ajout de la date		
				((ArrayList)programmations.get(i)[2]).add(date);
				trouve = true;
			}
			i++;	
		}
	}
	
	// ajoute une date à un programme et met à jour sa récurence (si la date possède "_")
	void ajouterDateProgramme(Object s, int[] date, boolean recurrence){
		int i = 0;
		boolean trouve = false;
		boolean doublon;
		// parcours de la liste programmations pour trouver le bon programme
		while(i < programmations.size() && !trouve){
			if(programmations.get(i)[0].equals(s.toString())){	
				ArrayList<Object> temporaire = ((ArrayList)programmations.get(i)[2]);
				doublon = false;
				// vérification si la date est déjà programmé ou non
				for(int j=0;j<temporaire.size();j++){
					int[] date_temp = (int[])temporaire.get(j);
					if(date[0] == date_temp[0] && date[1] == date_temp[1] && date[2] == date_temp[2] && date[3] == date_temp[3] && date[4] == date_temp[4]){
						doublon = true;
					}
				}
				// ajout de la date uniquement si la date n'est pas déjà programmé
				if(!doublon){
					((ArrayList)programmations.get(i)[2]).add(date);
					// mise à jour de la reccurence
					if(recurrence) programmations.get(i)[1] = recurrence; 
				}else{
					sortie_erreur += "Erreur ligne " + parser.pline() + ": doublon de date de la programmation du scenario "+s+".\n";
				}
				trouve = true;
			}
			i++;	
		}
}

	// vérification de la date et retour de la date dans un tableau d'entier
	int[] Date(Object d, Object s){
		// variables de test
		String date = (String) d;
		int annee = 0;
		int mois = 0;
		int jour = 0;
		int heure = 0;
		int minutes = 0;
		int annee_courante = Calendar.getInstance().get(Calendar.YEAR);
		int mois_courant = 0;
		boolean reccurence = false;
		// décomposition de la date
		String[] date_compose = date.split(",");
		int[] date_valide = new int[5];
		// on vérifie si la date est bien complète année, mois, jour, heure, minutes
		if(date_compose.length != 5){
			sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. nombre de paramêtre invalide.\n";
			return null;
		}
			
		// vérifications de annee, mois, jour, heure, minutes
		// annee
		// si l'annee possède de la recurrence
		if(date_compose[0].equals("_")){
			date_valide[0] = -1;
			reccurence = true;
		}else{
			try{
				annee = Integer.parseInt(date_compose[0]);
				// une annee pour être valide doit être supérieure ou égale à l'année courante
				if(annee >= annee_courante){
					date_valide[0] = annee;
				}else{
					sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. année invalide(inférieure à "+annee_courante+").\n";
					return null;
				}
			// en cas d'erreur du parse
			}catch(Exception e){
				sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. année invalide.\n";
				return null;
			}
		}
		// mois
		// si le mois possède de la recurrence
		if(date_compose[1].equals("_")){
			date_valide[1] = -1;	//
			reccurence = true;
		}else{
			try{
				mois = Integer.parseInt(date_compose[1]);
				// si l'annee correspond à l'année courante le mois doit être supérieur ou égal au mois courant
				if(date_valide[0] != -1 && annee == annee_courante){
					Calendar cal = Calendar.getInstance();
					cal.set(Calendar.YEAR, annee);
					mois_courant = cal.get(Calendar.MONTH)+1;
					if(mois >= mois_courant){
						date_valide[1] = mois;
					}else{
						sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. mois invalide.\n";
						return null;
					}
				// sinon le mois doit être en 1 et 12
				}else if(mois <= 12 && mois >= 1 && date_valide[0] != -1){
					date_valide[1] = mois;
				}else{
					sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. mois invalide.\n";
					return null;
				}
			// en cas d'erreur du parse
			}catch(Exception e){
				sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. mois invalide.\n";
				return null;
			}
		}
		//jour
		// si le jour possède de la recurrence
		if(date_compose[2].equals("_")){
			date_valide[2] = -1;
			reccurence = true;
		}else{
			try{
				jour = Integer.parseInt(date_compose[2]);
				Calendar cal = Calendar.getInstance();
				if(date_valide[0] != -1){
					cal.set(Calendar.YEAR, annee);
				}else{
					cal.set(Calendar.YEAR, annee_courante);
				}
				// si l'annee correspond à l'année courante, le mois au mois courant le jour doit être supérieur ou égal au jour courant
				// sinon il doit être entre 1 et 31 
				if(date_valide[1] != -1){
					cal.set(Calendar.MONTH, mois);
					int maxjour = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
					if(annee_courante == annee && mois == mois_courant){
						
						if(jour >= cal.get(Calendar.DAY_OF_MONTH) && jour <= maxjour){
							date_valide[2] = jour;
						}else{
							sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. jour invalide.\n";
							return null;
						}
					}else if(jour >= 1 && jour <= maxjour && annee_courante != annee){
						date_valide[2] = jour;
					}else{
						sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. jour invalide.\n";
						return null;
					}
				}else{
					if(jour >= 1 && jour <= 31){
						date_valide[2] = jour;
					}else{
						sortie_erreur += "Erreur ligne " + parser.pline() + ": date de la programmation du scenario "+s+" incorrect. jour invalide.\n";
						return null;
					}
				}
			// en cas d'erreur du parse
			}catch(Exception e){
				sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. jour invalide.";
				return null;
			}
		}
		//heure
		// si l'heure possède de la recurrence
		if(date_compose[3].equals("_")){
			date_valide[3] = -1;
			reccurence = true;
		}else{
			try{
				heure = Integer.parseInt(date_compose[3]);
				// une heure est comprise entre 0 et 23
				if(heure >= 0 && heure < 24){
					date_valide[3] = heure;
				}else{
					sortie_erreur += "Erreur ligne " + parser.pline() + " : date de la programmation du scenario "+s+" incorrect. heure invalide.\n";
					return null;
				}
			// en cas d'erreur du parse
			}catch(Exception e){
				sortie_erreur += "Erreur ligne " + parser.pline() + " : date de la programmation du scenario "+s+" incorrect. heure invalide.\n";
				return null;
			}
		}
		//minutes
		// si les minutes possèdent de la recurrence
		if(date_compose[4].equals("_")){
			date_valide[4] = -1;
			reccurence = true;
		}else{
			try{
				minutes = Integer.parseInt(date_compose[4]);
				// les minutes sont compris entre 0 et 59
				if(minutes >= 0 && minutes < 60){
					date_valide[4] = minutes;
				}else{
					sortie_erreur += "Erreur ligne " + parser.pline() + " : date de la programmation du scenario "+s+" incorrect. minutes invalide.\n";
					return null;
				}
			// en cas d'erreur du parse
			}catch(Exception e){
				sortie_erreur += "Erreur ligne " + parser.pline() + " : date de la programmation du scenario "+s+" incorrect. minutes invalide.\n";
				return null;
			}
		}
		return date_valide;
	}	

	// programme un scénario à une date, ajoute le programme dans la liste programmations
	void programmer(Object s, Object d){
		// si le scenario existe
		if(scenarioExiste(s)){
			// si le programme n'existe pas
			if(!programmeExiste(s)){
				// récuperation et vérifacation de la date dans un tableau d'entiers
				int[] date = Date(d, s);
				// si la date n'est pas null
				if(date != null){
					int i = 0;
					boolean recurent = false;
					// vérification de la réccurence de la date
					while(i<date.length && !recurent){
						if(date[i] == -1){
							recurent = true;
						}
						i++;
					}
					// ajout du programme à la liste programmations
					programmations.add(new Object[] {(String)s, recurent, new ArrayList<Object>()});
					// ajout de la date au programme qui vient d'être ajouté
					ajouterDateProgramme(s, date);			
				}
			}else{
				int[] date = Date(d, s);
				if(date != null){
					int i = 0;
					boolean recurent = false;
					// vérification de la réccurence de la date
					while(i<date.length && !recurent){
						if(date[i] == -1){
							recurent = true;
						}
						i++;
					}
					// ajout de la date au programme qui correspond au scénario
					ajouterDateProgramme(s, date, recurent);			
				}
			}
		}else{
			sortie_erreur += "Erreur ligne " + parser.pline() + " : scenario "+s+" inexistant.\n";
		}
	}

	// affiche la liste programmations
	String programmationToString(){
		String retour = "\n---- programmations ----\n";
		for(int i=0;i<programmations.size();i++){
			retour += ((String)programmations.get(i)[0])+" ("+((boolean)programmations.get(i)[1])+") [";
			ArrayList<Object> temporaire = (ArrayList<Object>)(programmations.get(i)[2]);
			for(int j=0;j<temporaire.size();j++){
				int[] date = (int[])temporaire.get(j);
				retour += "["+date[0]+"/"+date[1]+"/"+date[2]+"/"+date[3]+"/"+date[4]+"]";
			}
			retour += "]\n";
		}
		return retour;
   }
:}

parser code {:
	public static void main(String args[]) throws Exception {
		new parser(new Yylex(System.in)).parse();
	}

	public int pline(){
		return ((Yylex)getScanner()).getYyLine();
	}
	public int pcolumn(){
		return ((Yylex)getScanner()).getYyColumn();
	}
	public String ptext(){
		return ((Yylex)getScanner()).getYyText();
	}
:}

terminal DEBUT_DOMUS, FIN_DOMUS, DEBUT_APPAREIL, FIN_APPAREIL, DEBUT_INTERFACES, FIN_INTERFACES, DEBUT_SCENARII, FIN_SCENARII, DEBUT_COMMANDES, FIN_COMMANDES, APPAREIL, POINT, VIRGULE, IDENTIFICATEUR, ENUM, ASSIGNATION,  PAROUVRE, PARFERME, INTERFACE, DEBUT_SCENARIO, FIN_SCENARIO, FONCTION_ETAT, POINT_VIRGULE, EXECUTER_SCENARIO, MESSAGE, TEXTE, POURTOUT, PARCOURS, FAIRE, FAIT, SI, ALORS, SINON, FINSI, ASSOCIER, PROGRAMMER, DATE, ACFERME, ETAT, ACOUVRE, OPERATEUR, FIN_DE_BALISE;

non terminal ini, declaration,
liste_appareil, liste_identifiant_appareil, identifiant_appareil, liste_identifiant_appareil_enum, identifiant_appareil_enum, enum_appareil, appareil,
liste_interface, interface, identifiant_interface, liste_identifiant_interface,
scenarii, scenario, instructions_scenario, appel_fonction, fonction, fonction_valide, fonction_invalide, instruction, liste_instructions, execution, affichage, liste_elemts, elem, boucle, condition, test, entree, entree_appar, entree_ident, valeur, 
liste_commande,  commande, associer, liste_associer, liste_identifiant_associer, programmer, liste_date, liste_date_programmer;

ini ::= DEBUT_DOMUS declaration FIN_DOMUS {:
   
	if(code_valide) {
		System.out.println("Liste des appareils :");
		for(Object[] tab : appareils) {
			System.out.println("- nom : " + tab[0] + " | utilise : " + tab[1] + " | type : " + tab[2]);
		}

		System.out.println("\n\nListe des enumérations d'appareils :");
		for(Object[] tab1 : enums_appareils) {
			System.out.println("- nom : " + tab1[0] + " | son type est " + tab1[1] + " | ses valeurs sont : " + tab1[2]);
		}

		System.out.println("\nListe des interfaces :");
		for(Object[] tab2 : interfaces) {
			System.out.println("\n- nom : " + tab2[0] + " | utilise : " + tab2[1] 
			+ " | type : " + tab2[2] + " | ses scénarios sont : " + tab2[3]);
		}

		System.out.println("\nListe des scenarios : ");
		for(Object[] tab3 : scenarios) {
			System.out.println("- nom : " + tab3[0]);
		}
 
      System.out.println(associationToString());
      System.out.println(programmationToString());
	}
	System.out.println(sortie_erreur);
:};

declaration ::= DEBUT_APPAREIL liste_appareil  FIN_APPAREIL DEBUT_INTERFACES liste_interface FIN_INTERFACES DEBUT_SCENARII scenarii FIN_SCENARII DEBUT_COMMANDES liste_commande FIN_COMMANDES;

// ---------------------------DECLARATION APPAREIL---------------------------------------

liste_appareil ::= liste_appareil appareil | appareil | enum_appareil | liste_appareil enum_appareil;
//méthode pour déclarer un appareil ou plus avec, vérification du nom pour éviter les doublons
appareil ::= APPAREIL:t liste_identifiant_appareil POINT {:
	for(Object s : temp) {
		if(!appareilExiste(s)) appareils.add(new Object[] {s.toString(), false, t});
		else {
			sortie_erreur += "Erreur ligne " + parser.pline() + " : Impossible de déclarer deux fois le même identificateur (" + s.toString() + ").\n";
			code_valide = false;
		}
	}
	vider_tampon();
:};

liste_identifiant_appareil ::= liste_identifiant_appareil VIRGULE identifiant_appareil | identifiant_appareil;

identifiant_appareil ::= IDENTIFICATEUR:e{: temp.add(e); :};

// ------GESTION DES ENUMS ------

//méthode pour déclarer une énumération ou plus avec, vérification du nom pour éviter les doublons
enum_appareil ::= ENUM IDENTIFICATEUR:e ASSIGNATION ACOUVRE liste_identifiant_appareil_enum ACFERME POINT {:
	if(!enumAppareilExiste(e)) enums_appareils.add(new Object[] {e, type_enum, new ArrayList<Object>(temp)});
	else {
		sortie_erreur += "Erreur ligne " + parser.pline() + " : Impossible de déclarer deux fois le même identificateur (" + e + ").\n";
		code_valide = false;
	}
	vider_tampon();
:};

liste_identifiant_appareil_enum  ::= liste_identifiant_appareil_enum VIRGULE identifiant_appareil_enum | identifiant_appareil_enum;

identifiant_appareil_enum ::= IDENTIFICATEUR:e {:
	if(appareilExiste(e)) {type_enum = getTypeAppareil(e.toString()).toString(); temp.add(e);}
	else {
		sortie_erreur += "Erreur ligne " + parser.pline() + " : l'identificateur " + e + " n'existe pas.\n";
		code_valide = false;
	}
:};

// ---------------------------DECLARATION INTERFACE---------------------------------------

liste_interface ::= liste_interface interface | interface;
//méthode pour déclarer une interface ou plus avec, vérification pour éviter les doublons
interface ::= INTERFACE:t liste_identifiant_interface POINT {:
	for(Object s : temp) {
		if(!interfaceExiste(s)) interfaces.add(new Object[] {s.toString(), false, t, new ArrayList<Object>()});
		else {
			sortie_erreur += "Erreur ligne " + parser.pline() + " : Impossible de déclarer deux fois le même identificateur (" + s.toString() + ").\n";
			code_valide = false;
		}
	} 
	vider_tampon();
:};

liste_identifiant_interface ::= liste_identifiant_interface VIRGULE identifiant_interface| identifiant_interface;

identifiant_interface ::= IDENTIFICATEUR:e {:
	if(!interfaceExiste(e)) temp.add(e);
	else {System.out.println(" -- Erreur : identifiant " + e + " inexistant."); sortie_erreur += "Erreur ligne x : l'identificateur " + e + " n'existe pas.\n";}
:};

// ---------------------------DECLARATION SCENARII---------------------------------------

scenarii ::= scenarii scenario | scenario;

// ---------------------------DECLARATION SCENARIO---------------------------------------

//Définition de la structure du scénario
scenario ::= DEBUT_SCENARIO IDENTIFICATEUR:n {: nom_scenario = n.toString(); :} FIN_DE_BALISE instructions_scenario FIN_SCENARIO IDENTIFICATEUR:m FIN_DE_BALISE {:
	//Vérification de la disponiblité du nom
	if (scenarioExiste(n))
	{
		sortie_erreur += "Erreur ligne " + parser.pline() + " : Impossible de déclarer deux fois le même scénario (" + n.toString() + ").\n";
		code_valide = false;
	}
	else
	{
		scenarios.add(new Object [] {n.toString(), false});
		//System.out.println("scénario " + n + " ajouté");
	}
	//Vérification de la concordance des balises début/fin du scénario
   if(!m.toString().equals(nom_scenario)) {
      sortie_erreur += "Erreur ligne " + parser.pline() + " : l'identificateur de la balise de fin du scenario ne correspond pas à celui de la balise de début (" + nom_scenario + " != " + m.toString() + ").\n";
		code_valide = false;
   }
:};

instructions_scenario ::= instructions_scenario instruction | instruction;

//Ensemble des instructions disponibles pour un scénario
instruction ::= condition | affichage | execution | boucle | appel_fonction;

//Fonction : un appareil/enum appelle une fonction 
appel_fonction ::= IDENTIFICATEUR:i POINT fonction POINT_VIRGULE {:
	//Vérification de l'existence de l'appareil
   if(!appareilExiste(i)) {
      sortie_erreur += "Erreur ligne " + parser.pline() + " : l'identificateur " + i + " n'existe pas.\n";
		code_valide = false;   
   }
   	//Vérification du type de l'appareil pour savoir s'il peut utliser la fonction qu'il demande
	if (d.getFonctions(getTypeAppareil(i.toString()), temp.get(0).toString()))
	{
	   //System.out.println("l'appareil peut executer la fonction " + temp.get(0));
	}
	else
	{
		sortie_erreur += "Erreur ligne " + parser.pline() + " : cet appareil ne peut pas executer cette fonction (" + temp.get(0) + ").\n";
		code_valide = false;
	}
	vider_tampon();
:};
// fonction invalide = fonction non enregristrée 
fonction ::= fonction_valide | fonction_invalide;

fonction_valide ::= FONCTION_ETAT:f {: temp.add(f); :};

fonction_invalide ::= IDENTIFICATEUR:f {: temp.add(f); :};

execution ::= EXECUTER_SCENARIO IDENTIFICATEUR:s POINT_VIRGULE {:	if (scenarioExiste(s))
	{
	   //System.out.println("scénario existant, scenario lancé");
	}
	else
	{
		sortie_erreur += "Erreur ligne " + parser.pline() + " : scénario inexistant, scenario non lancé (" + s + ").\n";
		code_valide = false;
	}
:};
// affichage d'un message
affichage ::= MESSAGE PAROUVRE liste_elemts PARFERME POINT_VIRGULE;

liste_elemts ::= liste_elemts VIRGULE elem | elem;

elem ::= TEXTE | IDENTIFICATEUR:s {: if (appareilExiste(s))
	{
	   //System.out.println("Appareil existant, scenario lancé");
	}
	else
	{
		sortie_erreur += "Erreur ligne " + parser.pline() + " : appareil inexistant, scenario non lancé (" + s.toString() + ").\n";
		code_valide = false; 
	}
:};
// = Poutout
boucle ::= POURTOUT IDENTIFICATEUR:a {: temp.add(a); :} PARCOURS entree FAIRE instruction FAIT POINT_VIRGULE {: 
		supprimer_appareil(a.toString());
:};

entree ::= entree_appar | entree_ident;
// Si appareil - on vérfie s'il existe
entree_appar ::= APPAREIL:a {: if (d.typeAppareilExiste(a)) {
		appareils.add(new Object[] {temp.get(0), false, a.toString()});
		vider_tampon();
	}
	else
	{
      System.out.println("attention l'appareil " + a + " n'existe pas !");
		sortie_erreur += "Erreur ligne " + parser.pline() + " : type appareil inexistant (" + d.toString() + "), boucle invalide.\n";
		code_valide = false;
		vider_tampon();
	}
:};
// Si enumération - on vérfie si elle existe
entree_ident ::= IDENTIFICATEUR:a {: if (enumAppareilExiste(a)) {
		appareils.add(new Object[] {temp.get(0), false, getTypeEnum(a.toString())});
		vider_tampon();
	}
	else
	{
      System.out.println("attention l'enumération " + a + " n'existe pas !");
		sortie_erreur += "Erreur ligne " + parser.pline() + " : Enumération d'appareils inexistante (" + a.toString() + "), boucle invalide .\n";
		code_valide = false;
      vider_tampon();
	}
:};
// Si
condition ::= SI test ALORS liste_instructions FINSI POINT_VIRGULE | SI test ALORS liste_instructions SINON liste_instructions FINSI POINT_VIRGULE;
// la condition du Si
test ::= PAROUVRE valeur OPERATEUR valeur PARFERME;
// valeur = une fonction d'un appareil OU son état 
valeur ::= IDENTIFICATEUR POINT FONCTION_ETAT | ETAT;

liste_instructions ::= liste_instructions VIRGULE instruction | instruction;

// ---------------------------DECLARATION COMMANDE---------------------------------------

liste_commande ::= liste_commande commande | commande ;

commande ::= associer | programmer;

associer ::= ASSOCIER IDENTIFICATEUR:i ASSIGNATION liste_associer POINT {:  	
	System.out.println(liste_association_scenarios.toString());
	Association_multiple(i);
:} | ASSOCIER IDENTIFICATEUR:i ASSIGNATION IDENTIFICATEUR:s POINT {:
	Association_simple(i, s);
:};

liste_associer ::= ACOUVRE liste_identifiant_associer ACFERME;

liste_identifiant_associer ::= liste_identifiant_associer VIRGULE IDENTIFICATEUR:s {:
	if(!liste_association_scenarios.contains((String)s)) {
		liste_association_scenarios.add((String)s);
	} else {
		sortie_erreur += "\nErreur ligne " + parser.pline() + " : scenario "+s+" déjà présent dans l'énumération de scénarios.\n";
		code_valide = false;	
	}
:} | IDENTIFICATEUR:s {:
	if(!liste_association_scenarios.contains((String)s)) {
		liste_association_scenarios.add((String)s);
	} else {
		sortie_erreur += "\nErreur ligne " + parser.pline() + " : scenario "+s+" déjà présent dans l'énumération de scénarios.\n";	
		code_valide = false;
	}
:};

programmer ::= PROGRAMMER IDENTIFICATEUR:s ASSIGNATION liste_date POINT 
{: 
	for(int i=0; i<liste_programme_date.size();i++) {
		System.out.println(s+" "+liste_programme_date.get(i));
		programmer(s,liste_programme_date.get(i));
	}
	liste_programme_date.clear();
:} | PROGRAMMER IDENTIFICATEUR:s ASSIGNATION PAROUVRE DATE:d PARFERME POINT {:
	programmer(s,d);
:};

liste_date ::= ACOUVRE liste_date_programmer ACFERME;

liste_date_programmer ::= liste_date_programmer VIRGULE PAROUVRE DATE:d PARFERME {:
	if(!liste_programme_date.contains(d)) {
		liste_programme_date.add(d);
	}else{
		sortie_erreur += "Erreur ligne " + parser.pline() + " : date déjà présente dans l'énumération de dates.\n";
		code_valide = false;
	}
:} | PAROUVRE DATE:d PARFERME {:
	if(!liste_programme_date.contains(d)){
		liste_programme_date.add(d);
	}else{
		sortie_erreur += "Erreur ligne " + parser.pline() + " : date déjà présente dans l'énumération de dates.\n";
		code_valide = false;
	}
:};
