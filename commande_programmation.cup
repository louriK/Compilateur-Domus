// Specification JCup
import java_cup.runtime.*;
import java.util.*;
import java.io.*;

parser code {:
	public static void main(String args[]) throws Exception {
		new parser(new Yylex(System.in)).parse();
	}
/*
   public void syntax_error(Symbol cur_token) { 
		// n'interrompt pas la compil... 
		// on est par defaut dans l'etat error qui permet ensuite la recup
		// par défaut : report_error("syntax error", null);
		report_error("Syntaxe incorrecte <"+tokenToString(cur_token)+">", null);        
	}

	public void report_error(String message, Object info) {   
		// n'interrompt pas la compil
		if (info == null) System.err.println("Mon erreur <"+ ptext()+ "> ligne "+ pline() + ", colonne " + pcolumn() + " : " + message);
		else System.err.println("Mon erreur <"+ptext()+ "> ligne "+ pline() + ", colonne " + pcolumn() + " : " +message+" : "+info);
		System.err.println("-> mais on continue l'analyse... ");
	}

	public void unrecovered_syntax_error(Symbol cur_token) {
    	// par defaut : report_fatal_error("Couldn't repair and continue parse", null);
		// on n'a pas reussi a faire de la recup
		report_fatal_error("Recuperation impossible <"+tokenToString(cur_token)+">", null);   // interrompt la compil     
	}

	public void report_fatal_error(String message, Object info) {  
		// qd cette fct est appelee, message vaut par defaut "Couldn't repair and continue parse"
		String m = "Mon erreur fatale <"+ ptext()+ "> ligne " + pline() + ", colonne " + pcolumn() + " : " + message;
		if (info == null) System.err.println(m);
		else System.err.println(m+" : "+info);
		System.err.println("-> arrêt de l'analyse...");
		done_parsing(); // interrompt la compil
  	}

	public int pline(){
		return ((Yylex)getScanner()).getYyLine();
	}
	public int pcolumn(){
		return ((Yylex)getScanner()).getYyColumn();
	}
	public String ptext(){
		return ((Yylex)getScanner()).getYyText();
	}


   public String tokenToString (Symbol token) {
   // qqs exemples pour voir...
        switch (token.sym) {
	   case sym.SI : return "SI"; 
	   case sym.CHAINE : return "CHAINE "+token.value;  
	   case sym.ENTIER : return "ENTIER "+token.value;  
	   //  ... A compléter !!
	   default : return "Token imprévu ou error";
	   }
   }
*/
:}

init with {:
   // 0 = eclairage, 1 = alarme, 2 = chauffage, 3 = fenetre, 4 = volet, 5 = autre_appareil
   String [][] functions = new String [6][];
   functions[0] = new String[] {"allumer", "eteindre", "tamiser"};
   functions[1] = new String[] {"allumer", "allumer_partiel", "éteindre"};
   functions[2] = new String[] {"allumer", "allumer_eco", "éteindre"};
   functions[3] = new String[] {"ouvrir", "ouvrir_partiel", "fermer", "fermer_partiel"};
   functions[4] = new String[] {"ouvrir", "ouvrir_partiel", "fermer", "fermer_partiel"};
   functions[5] = new String[] {"allumer", "éteindre"};


   // 0 = eclairage, 1 = alarme, 2 = chauffage, 3 = fenetre, 4 = volet, 5 = autre_appareil
   String [][] etats = new String [6][];
   etats[0] = new String[] {"allumé", "éteint", "demi"};
   etats[1] = new String[] {"allumé", "eteint", "demi"};
   etats[2] = new String[] {"allumé", "eteint", "éco"};
   etats[3] = new String[] {"ouvert", "fermé", "demi"};
   etats[4] = new String[] {"ouvert", "fermé", "demi"};
   etats[5] = new String[] {"allumé", "eteint"};
:}


action code {:
	 // variables de test pour association
	 ArrayList<Object> liste_association_scenarios = new ArrayList<Object>();
	 ArrayList<Object> liste_programme_date = new ArrayList<Object>();
	 String sortie_erreur = "";

   List<Object[]> appareils = new ArrayList<Object[]>();
   ArrayList<Object[]> interfaces = new ArrayList<Object[]>();
   ArrayList<Object[]> scenarios = new ArrayList<Object[]>();
   List<Object[]> associations = new ArrayList<Object[]>();
   List<Object[]> programmations = new ArrayList<Object[]>();
   List<Object[]> enums_appareils = new ArrayList<Object[]>();
   List<Object[]> enums_dates = new ArrayList<Object[]>();

  void exemple_de_fonction(String i1, String i2)
   {
       String m = "Erreur syntaxique <"+i2+"> au lieu de <"+i1+">";
       if (!(i1.equals(i2))) parser.report_error(m,null);    
   }

	void init(){
		//test interfaces
		interfaces.add(new Object[] {"b1", false, "interrupteur", new ArrayList<String>()});
		interfaces.add(new Object[] {"b2", false, "interrupteur", new ArrayList<String>()});
		interfaces.add(new Object[] {"t1", false, "mobile", new ArrayList<String>()});
		interfaces.add(new Object[] {"c1", false, "telecommande", new ArrayList<String>()});
		interfaces.add(new Object[] {"c2", false, "telecommande", new ArrayList<String>()});
			
		//programmations.add(new Object[] {"c2", false, new ArrayList<String>()});

		//test scenarios
		scenarios.add(new Object[] {"bonjour", false});
		scenarios.add(new Object[] {"soiree", false});
		scenarios.add(new Object[] {"soiree_musique", false});
		scenarios.add(new Object[] {"depart", false});
		scenarios.add(new Object[] {"noel1", false});
		scenarios.add(new Object[] {"noel2", false});
		scenarios.add(new Object[] {"noel3", false});
	}


	
	// ---------------global---------------

	boolean appareilExiste(Object chaine){
      int i  = 0;
      boolean trouve = false;
      while(i < appareils.size() && !trouve) {
         if(appareils.get(i)[0].equals(chaine.toString())){ trouve = true;}
		 i++;
      }
      return trouve;
   }

   boolean interfaceExiste(Object chaine){
      int i  = 0;
      boolean trouve = false;
      while(i < interfaces.size() && !trouve) {
         if(interfaces.get(i)[0].equals(chaine.toString())){ trouve = true;}
		 i++;
      }
      return trouve;
   }

	boolean scenarioExiste(Object chaine){
      int i  = 0;
      boolean trouve = false;
      while(i < scenarios.size() && !trouve) {
         if(scenarios.get(i)[0].equals(chaine.toString())){ trouve = true;} //
		 i++;
      }
      return trouve;
   }

   boolean programmeExiste(Object s){
		int i  = 0;
		boolean trouve = false;
		while(i < programmations.size() && !trouve) {
			if(programmations.get(i)[0].equals(s.toString())){ trouve = true;}
			i++;
		}
		return trouve;
   }

	Object[] getInterface(Object chaine){
		int i = 0;
		boolean trouve = false;
		while(i < interfaces.size() && !trouve){
			if(interfaces.get(i)[0].equals(chaine.toString())){ trouve = true;
			}else{
				i++;
			}
		}
		return interfaces.get(i);
	}

	Object[] getScenario(Object chaine){
		int i = 0;
		boolean trouve = false;
		while(i < scenarios.size() && !trouve){
			if(scenarios.get(i)[0].equals(chaine.toString())){ trouve = true;
			}else{
				i++;
			}
		}
		return scenarios.get(i);
	}

	Object[] getProgramme(Object chaine){
		int i = 0;
		boolean trouve = false;
		while(i < programmations.size() && !trouve){
			if(programmations.get(i)[0].equals(chaine.toString())){ trouve = true;
			}else{
				i++;
			}
		}
		return programmations.get(i);
	}

	// ---------------association---------------

	void ajoutScenarInterface(Object inter, Object scenar){
		int i = 0;
		boolean trouve = false;
		while(i < interfaces.size() && !trouve){
			if(interfaces.get(i)[0].equals(inter.toString())){			
				((ArrayList)interfaces.get(i)[3]).add((String)scenar);
				if(!(Boolean)interfaces.get(i)[1])interfaces.get(i)[1] = true;
				getScenario(scenar)[1] = true;
				trouve = true;
			}
			i++;	
		}
	}

	void Association_simple(Object i, Object s){
		if(interfaceExiste(i)){
			if(!(Boolean)getInterface(i)[1]){
				if(scenarioExiste(s)){
					ajoutScenarInterface(i,s);
					associations.add(new Object[] {(String)i, new ArrayList<Object>()});
					((ArrayList)associations.get(associations.size()-1)[1]).add((String)s);
				}else{
					sortie_erreur += "\nerreur :: scenario "+s+" inexistant.";
				}
			}else{
				sortie_erreur += "\nerreur :: l'interface "+i+" à déjà un ou des scénario(s) associé(s).";
			}
		}else{
			sortie_erreur += "\nerreur :: interface "+i+" inexistante.";	
		}
	}

	void Association_multiple(Object i){
		if(interfaceExiste(i)){
			if(!(Boolean)getInterface(i)[1]){
				if(!(((String)getInterface(i)[2]).equals("interrupteur"))){
					if(liste_association_scenarios != null){
						int j;
						for(j=0; j<liste_association_scenarios.size();j++){	
							if(scenarioExiste(liste_association_scenarios.get(j))){
								ajoutScenarInterface(i,liste_association_scenarios.get(j));
								if(j==0) associations.add(new Object[] {(String)i, new ArrayList<Object>()});
								((ArrayList)associations.get(associations.size()-1)[1]).add(liste_association_scenarios.get(j));
							}else{
								sortie_erreur += "\nerreur :: scenario "+liste_association_scenarios.get(j)+" inexistant.";
							}
						}
					}else{
						sortie_erreur += "\nerreur :: liste pour l'association à l'interface "+i+" vide.";			
					}
				}else{
					sortie_erreur += "\nerreur ::le type de l'interface "+i+" ne permet pas l'association de scenarii.";
				}
			}else{
				sortie_erreur += "\nerreur :: l'interface "+i+" à déjà un ou des scénario(s) associé(s).";
			}
		}else{
			sortie_erreur += "\nerreur :: interface "+i+" inexistante.";	
		}
		liste_association_scenarios.clear();
	}
	
	String associationToString(){
		String retour = "\n---- association ----\n";
		for(int i=0;i<associations.size();i++){
			retour += ((String)associations.get(i)[0])+" "+((ArrayList)associations.get(i)[1])+"\n";
		}
		return retour;
	}

	// ---------------programme---------------

	void ajouterDateProgramme(Object s, int[] date){
		int i = 0;
		boolean trouve = false;
		while(i < programmations.size() && !trouve){
			if(programmations.get(i)[0].equals(s.toString())){			
				((ArrayList)programmations.get(i)[2]).add(date);
				trouve = true;
			}
			i++;	
		}
	}

	void ajouterDateProgramme(Object s, int[] date, boolean recurrence){
		int i = 0;
		boolean trouve = false;
		boolean doublon;
		while(i < programmations.size() && !trouve){
			if(programmations.get(i)[0].equals(s.toString())){	
				ArrayList<Object> temporaire = ((ArrayList)programmations.get(i)[2]);
				doublon = false;
				for(int j=0;j<temporaire.size();j++){
					int[] date_temp = (int[])temporaire.get(j);
					if(date[0] == date_temp[0] && date[1] == date_temp[1] && date[2] == date_temp[2] && date[3] == date_temp[3] && date[4] == date_temp[4]){
						doublon = true;
					}
				}
				if(!doublon){
					((ArrayList)programmations.get(i)[2]).add(date);
					if(recurrence) programmations.get(i)[1] = recurrence; 
				}else{
					sortie_erreur += "\nerreur :: doublon de date de la programmation du scenario "+s+".";
				}
				trouve = true;
			}
			i++;	
		}
	}

	int[] Date(Object d, Object s){
		String date = (String) d;
		int annee = 0;
		int mois = 0;
		int jour = 0;
		int heure = 0;
		int minutes = 0;
		int annee_courante = Calendar.getInstance().get(Calendar.YEAR);
		int mois_courant = 0;
		boolean reccurence = false;
		String[] date_compose = date.split(",");
		int[] date_valide = new int[5];
		if(date_compose.length != 5){
			sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. nombre de paramêtre invalide.";
			return null;
		}
		// annee
		if(date_compose[0].equals("_")){
			date_valide[0] = -1;
			reccurence = true;
		}else{
			try{
				annee = Integer.parseInt(date_compose[0]);
				if(annee >= annee_courante){
					date_valide[0] = annee;
				}else{
					sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. année invalide(inférieure à "+annee_courante+").";
					return null;
				}
			}catch(Exception e){
				sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. année invalide.";
				return null;
			}
		}
		// mois
		if(date_compose[1].equals("_")){
			date_valide[1] = -1;	//
			reccurence = true;
		}else{
			try{
				mois = Integer.parseInt(date_compose[1]);
				if(date_valide[0] != -1 && annee == annee_courante){
					Calendar cal = Calendar.getInstance();
					cal.set(Calendar.YEAR, annee);
					mois_courant = cal.get(Calendar.MONTH)+1;
					if(mois >= mois_courant){
						date_valide[1] = mois;
					}else{
						sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. mois invalide.";
						return null;
					}
				}else if(mois <= 12 && mois >= 1 && date_valide[0] != -1){
					date_valide[1] = mois;
				}else{
					sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. mois invalide.";
					return null;
				}
			}catch(Exception e){
				sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. mois invalide.";
				return null;
			}
		}
		//jour
		if(date_compose[2].equals("_")){
			date_valide[2] = -1;
			reccurence = true;
		}else{
			try{
				jour = Integer.parseInt(date_compose[2]);
				Calendar cal = Calendar.getInstance();
				if(date_valide[0] != -1){
					cal.set(Calendar.YEAR, annee);
				}else{
					cal.set(Calendar.YEAR, annee_courante);
				}
				
				if(date_valide[1] != -1){
					cal.set(Calendar.MONTH, mois);
					int maxjour = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
					if(annee_courante == annee && mois == mois_courant){
						
						if(jour >= cal.get(Calendar.DAY_OF_MONTH) && jour <= maxjour){
							date_valide[2] = jour;
						}else{
							sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. jour invalide.";
							return null;
						}
					}else if(jour >= 1 && jour <= maxjour && annee_courante != annee){
						date_valide[2] = jour;
					}else{
						sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. jour invalide.";
						return null;
					}
				}else{
					if(jour >= 1 && jour <= 31){
						date_valide[2] = jour;
					}else{
						sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. jour invalide.";
						return null;
					}
				}
			}catch(Exception e){
				sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. jour invalide.";
				return null;
			}
		}
		//heure
		if(date_compose[3].equals("_")){
			date_valide[3] = -1;
			reccurence = true;
		}else{
			try{
				heure = Integer.parseInt(date_compose[3]);
				if(heure >= 0 && heure < 24){
					date_valide[3] = heure;
				}else{
					sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. heure invalide.";
					return null;
				}
			}catch(Exception e){
				sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. heure invalide.";
				return null;
			}
		}
		//minutes
		if(date_compose[4].equals("_")){
			date_valide[4] = -1;
			reccurence = true;
		}else{
			try{
				minutes = Integer.parseInt(date_compose[4]);
				if(minutes >= 0 && minutes < 60){
					date_valide[4] = minutes;
				}else{
					sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. minutes invalide.";
					return null;
				}
			}catch(Exception e){
				sortie_erreur += "\nerreur :: date de la programmation du scenario "+s+" incorrect. minutes invalide.";
				return null;
			}
		}
		return date_valide;
	}	

	void programmer(Object s, Object d){
		if(scenarioExiste(s)){
			if(!programmeExiste(s)){
				int[] date = Date(d, s);
				if(date != null){
					int i = 0;
					boolean recurent = false;
					while(i<date.length && !recurent){
						if(date[i] == -1){
							recurent = true;
						}
						i++;
					}
					programmations.add(new Object[] {(String)s, recurent, new ArrayList<Object>()});
					ajouterDateProgramme(s, date);			
				}
			}else{
				int[] date = Date(d, s);
				if(date != null){
					int i = 0;
					boolean recurent = false;
					while(i<date.length && !recurent){
						if(date[i] == -1){
							recurent = true;
						}
						i++;
					}
					ajouterDateProgramme(s, date, recurent);			
				}
			}
		}else{
			sortie_erreur += "\nerreur :: scenario "+s+" inexistant.";
		}
	}

	String parametreToString(){
		String retour = "\n---- programmations ----\n";
		for(int i=0;i<programmations.size();i++){
			retour += ((String)programmations.get(i)[0])+" ("+((boolean)programmations.get(i)[1])+") [";
			ArrayList<Object> temporaire = ((ArrayList)programmations.get(i)[2]);
			for(int j=0;j<temporaire.size();j++){
				int[] date = (int[])temporaire.get(j);
				retour += "["+date[0]+"/"+date[1]+"/"+date[2]+"/"+date[3]+"/"+date[4]+"]";
			}
			retour += "]\n";
		}
		return retour;
	}

:}

terminal DEBUT_DOMUS, FIN_DOMUS, DEBUT_APPAREIL, FIN_APPAREIL, DEBUT_INTERFACES, FIN_INTERFACES, DEBUT_SCENARII, FIN_SCENARII, DEBUT_COMMANDES, FIN_COMMANDES, APPAREIL, POINT, VIRGULE, IDENTIFICATEUR, ENUM, ASSIGNATION,  PAROUVRE, PARFERME, INTERFACE, DEBUT_SCENARIO, FIN_SCENARIO, FONCTION_ETAT, POINT_VIRGULE, EXECUTER_SCENARIO, MESSAGE, TEXTE, POURTOUT, PARCOURS, FAIRE, FAIT, SI, ALORS, SINON, FINSI, ASSOCIER, PROGRAMMER, DATE, ACFERME, ETAT, ACOUVRE, OPERATEUR, FIN_DE_BALISE;

non terminal ini, declaration, liste_interface, liste_commande, liste_identifiant_appareil, interface, scenarii, commande, appareil, enum_appareil, liste_identifiant_interface, scenario, instruction, execution, affichage, liste_elemts, elem, boucle, condition, associer, liste_associer, liste_identifiant_associer, programmer, liste_date, liste_date_programmer, test, liste_instructions, entrees_appareil, entree, valeur;

ini ::= DEBUT_DOMUS declaration FIN_DOMUS {:System.out.println(associationToString()); System.out.println(parametreToString()); System.out.println(sortie_erreur);:};

declaration ::= DEBUT_APPAREIL entrees_appareil  FIN_APPAREIL DEBUT_INTERFACES liste_interface FIN_INTERFACES DEBUT_SCENARII scenarii FIN_SCENARII DEBUT_COMMANDES liste_commande FIN_COMMANDES;

// ---------------------------DECLARATION APPAREIL---------------------------------------

entrees_appareil ::= entrees_appareil appareil | appareil | enum_appareil | entrees_appareil enum_appareil;

appareil ::= APPAREIL liste_identifiant_appareil POINT;

enum_appareil ::= ENUM IDENTIFICATEUR ASSIGNATION ACOUVRE liste_identifiant_appareil ACFERME POINT;

liste_identifiant_appareil ::= liste_identifiant_appareil VIRGULE IDENTIFICATEUR | IDENTIFICATEUR;

// ---------------------------DECLARATION INTERFACE---------------------------------------

liste_interface ::= liste_interface interface | interface;

interface ::= INTERFACE liste_identifiant_interface POINT;

liste_identifiant_interface ::= liste_identifiant_interface VIRGULE IDENTIFICATEUR| IDENTIFICATEUR;

// ---------------------------DECLARATION SCENARII---------------------------------------

scenarii ::= scenarii DEBUT_SCENARIO IDENTIFICATEUR FIN_DE_BALISE scenario FIN_SCENARIO IDENTIFICATEUR FIN_DE_BALISE |DEBUT_SCENARIO IDENTIFICATEUR FIN_DE_BALISE scenario FIN_SCENARIO IDENTIFICATEUR FIN_DE_BALISE;

// ---------------------------DECLARATION SCENARIO---------------------------------------

scenario ::= scenario instruction | instruction;

instruction ::= condition | affichage | execution | boucle | IDENTIFICATEUR POINT FONCTION_ETAT POINT_VIRGULE;

execution ::= EXECUTER_SCENARIO IDENTIFICATEUR POINT_VIRGULE;

affichage ::= MESSAGE PAROUVRE liste_elemts PARFERME POINT_VIRGULE;

liste_elemts ::= liste_elemts VIRGULE elem | elem;
elem ::= TEXTE | IDENTIFICATEUR;

boucle ::= POURTOUT IDENTIFICATEUR PARCOURS entree FAIRE instruction FAIT POINT_VIRGULE;

entree ::= APPAREIL | IDENTIFICATEUR;

condition ::= SI test ALORS liste_instructions FINSI POINT_VIRGULE | SI test ALORS liste_instructions SINON liste_instructions FINSI POINT_VIRGULE;

test ::= PAROUVRE valeur OPERATEUR valeur PARFERME;

valeur ::= IDENTIFICATEUR POINT FONCTION_ETAT | ETAT;

liste_instructions ::= liste_instructions VIRGULE instruction | instruction;

// ---------------------------DECLARATION COMMANDE---------------------------------------

liste_commande ::= liste_commande commande | {: init();:} commande ;

commande ::= associer | programmer;

associer ::= 
ASSOCIER IDENTIFICATEUR:i ASSIGNATION liste_associer POINT 
{:  	
	System.out.println(liste_association_scenarios.toString());
	Association_multiple(i);
:}
| ASSOCIER IDENTIFICATEUR:i ASSIGNATION IDENTIFICATEUR:s POINT
{:
	Association_simple(i, s);
:};

liste_associer ::= ACOUVRE liste_identifiant_associer ACFERME;

liste_identifiant_associer ::= liste_identifiant_associer VIRGULE IDENTIFICATEUR:s
{:
	if(!liste_association_scenarios.contains((String)s)){
		liste_association_scenarios.add((String)s);
	}else{
		sortie_erreur += "\nerreur :: scenario "+s+" déjà présent dans l'énumération de scénarios.";	
	}
:} | IDENTIFICATEUR:s
{:
	if(!liste_association_scenarios.contains((String)s)){
		liste_association_scenarios.add((String)s);
	}else{
		sortie_erreur += "\nerreur :: scenario "+s+" déjà présent dans l'énumération de scénarios.";	
	}
:};

programmer ::= PROGRAMMER IDENTIFICATEUR:s ASSIGNATION liste_date POINT 
{: 
	for(int i=0; i<liste_programme_date.size();i++){
		System.out.println(s+" "+liste_programme_date.get(i));
		programmer(s,liste_programme_date.get(i));
	}
	liste_programme_date.clear();
:} | PROGRAMMER IDENTIFICATEUR:s ASSIGNATION PAROUVRE DATE:d PARFERME POINT
{:
	programmer(s,d);
:};

liste_date ::= ACOUVRE liste_date_programmer ACFERME;

liste_date_programmer ::= liste_date_programmer VIRGULE PAROUVRE DATE:d PARFERME 
{:
	if(!liste_programme_date.contains(d)){
		liste_programme_date.add(d);
	}else{
		sortie_erreur += "\nerreur :: date déjà présente dans l'énumération de dates.";	
	}
:}| PAROUVRE DATE:d PARFERME
{:
	if(!liste_programme_date.contains(d)){
		liste_programme_date.add(d);
	}else{
		sortie_erreur += "\nerreur :: date déjà présente dans l'énumération de dates.";	
	}
:};




